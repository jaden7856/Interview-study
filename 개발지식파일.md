# 1. Json과 Dict의 차이

### Dictionary object

dictionary 자료형은 `{key:value}` 형태를 갖는다. 순서가 없는 자료형이기 때문에 인덱스가 아닌 key 값으로 접근해 value값을 얻는다.

`key` 로 사용할 수 있는 값은 hashmap에 저장할 수 있는 hashable type 이어야 한다.

- hashable object인 숫자, 문자열, tuple은 key로 사용할 수 있다.
- tuple의 경우, list, dictionary를 요소로 갖고있는 tuple은 key로 사용할 수 없다.
- hashable 하지 않은 object인 list, dictionary를 사용할 경우 TypeError가 발생한다.

> `hashable object` 는 object의 생명주기 동안 변하지 않는 hash 값을 가진다. hash() 함수를 이용해 hash 값을 확인할 수 있다. hashable object만 가능하며, hashable하지 않은 object의 hash 값을 얻으려고 할 경우 TypeError가 발생한다. 두 object의 hash 값을 같은지 비교하기 위해서는 `obj.__eq__(obj2)` 함수를 사용하면 된다. [[dict type 문서 링크\]](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict) [[hashable 문서 링크\]](https://docs.python.org/2/glossary.html#term-hashable)

`value`에는 모든 object를 사용할 수 있다.

- value는 중복될 수 있지만, key가 중복되면 마지막에 등록한 값으로 덮어씌워진다.
- value의 값을 변경하기 위해서는 `d[key] = new_value` 형식으로 변경해주면 된다.





### JSON

JSON(JavaScript Object Notation)은 텍스트 기반으로 데이터를 전달하기 위해 만들어진 형식이다. 웹 브라우저-웹 서버 사이에 데이터를 교환하는데 많이 사용하는 형식이다. 텍스트 기반이기때문에 사람이 볼 때에 쉽게 확인할 수 있다. 주로 Key-value 쌍으로 데이터를 저장한다. 이를 JSON에서는 object라고 부른다.

**JSON 표기법**

- JSON object는 {중괄호}로 표기한다.
- JSON array는 [대괄호]로 표기한다.
- Key(속성): Value(값) 형태로 표기한다.
  - Key(속성)은 "쌍따옴표"로 묶어서 문자열로 표기한다. 숫자도 문자열로 표현된다.
  - Value(값)은 모든 자료형이 가능하며 자료형에 따라 표기 방법이 달라진다.
- 속성이 여러개인 경우 `,` 로 구분한다.
- JSON은 기본적으로 유니코드 인코딩을 사용한다.





# 2. MVC(Model-View-Controller)

개발 할 때, 3가지 형태로 역할을 나누어 개발하는 방법론입니다.

비지니스 처리 로직과 사용자 인터페이스 요소들을 분리시켜 서로 영향없이 개발 하기 수월하다는 장점이 있습니다.

**`Model`**은 어플리케이션이 “**무엇**”을 할 것인지를 정의 합니다. 내부 비지니스 로직을 처리하기 위한 역할을 할 것입니다.

- 처리되는 알고리즘, DB 와 상호작용(**CRUD** Create Read Update Delete), 데이터 등등..



**`Controller`**는 모델이 “**어떻게**” 처리할 지를 알려주는 역할을 할 것이고, 모바일에서는 **화면의 로직처리** 부분입니다. 화면에서 사용자의 요청을 받아서 처리되는 부분을 구현되게 되며, 요청 내용을 분석해서 Model과 View에 업데이트 요청을 하게 됩니다.

- **사용자**로 부터의 입력 을 받고 Model 또는 View중개인 역할



**`View`**는 화면에 “**무엇”** 인가를 “**보여주기 위한 역할”**을 합니다. 컨트롤러 하위에 종속되어, 모델이나 컨트롤러가 보여주려고 하는 모든 필요한 것들을 보여줄 것입니다.

- **최종 사용자**에게 “무엇”을 화면(UI)으로 보여줌
  - 클라이언트 측 기술인 html/css/javascript들을 모아둔 컨테이너이다.



그리고 Controller는 Model과 View가 각각 무엇을 해야 할 지를 알고 있고, 통제합니다. 비지니스 로직을 처리하는 Model과 완전히 UI에 의존적인 View가 서로 직접 이야기 할 수 없게 합니다.

![img](개발지식파일.assets/1262.png)





### Web과 MVC

위의 개념을 웹에 적용해보자. 

1. 사용자가 웹사이트에 접속한다. (Uses)
2. Controller는 사용자가 요청한 웹페이지를 서비스 하기 위해서 모델을 호출한다. (Manipulates)
3. 모델은 데이터베이스나 파일과 같은 데이터 소스를 제어한 후에 그 결과를 리턴한다.
4. Controller는 Model이 리턴한 결과를 View에 반영한다. (Updates)
5. 데이터가 반영된 VIew는 사용자에게 보여진다. (Sees)





### MVC의 한계

MVC에서 View는 Controller에 연결되어 화면을 구성하는 단위요소이므로 다수의 View들을 가질 수 있습니다. 그리고 Model은 Controller를 통해서 View와 연결되어지지만, 이렇게 Controller를 통해서 하나의 View에 연결될 수 있는 Model도 여러개가 될 수 있습니다.

> 뷰와 모델이 서로 의존성을 띄게 됩니다.

즉, 화면에 복잡한 화면과 데이터의 구성 필요한 구성이라면, Controller에 다수의 Model과 View가 복잡하게 연결되어 있는 상황이 생길 수 있습니다

MVC가 너무 복잡하고 비대해져서, 새 기능을 추가할때마다 크고 작은 문제점을 가지고 소드 분석이나 테스트도 어렵죠. 이런 형태의 MVC를

> **Massive** ViewController (대규모 MVC 어플리케이션)

라고 부릅니다. MVC의 한계를 표현한 용어 인 것 같습니다.

대부분의 사람들(당연히 저도 포함)은 MVC를 구성할 때, View와 Model을 중재하는 Controller를 작성하면 Controller의 비중이 크지 않을 것으로 생각했지만, 복잡한 화면을 구현하게 되면 대규모 MVC 어플리케이션 형태로 구현하게 되었습니다.

Controller는 View와 라이프 사이클과 강하게 연결되어있어서 분리할 수도 없고, 코드 분석/수정과 테스트가 모두 힘들어지죠. 그리고 복잡하게 엮어있는 모델과 뷰는 여러 Side-Effect를 불러와서 프로그램 운영을 힘들게 하지요.

그래서 위의 문제점을 보완한 여러 다양한!! 패턴을 파생시켰습니다.

MVP, MVVM, Viper, Clean Architecture, Flux, Redux, RxMVVM….





# 3. PEP 8

- PEP8 : 파이썬 개선 제안서, 파이썬 코드를 어떻게 구상할 지 알려주는 스타일 가이드
- [PEP8 전체 가이드](https://www.python.org/dev/peps/pep-0008/)
- 다른 사람과 원활하게 협업하려면 공통된 스타일 공유가 필요
- 일관성 있는 스타일은 나중에 수정하기도 쉽다.



### whitespace

- 한 줄의 문자 길이가 79자 이하여야 한다.
- 함수와 클래스는 `빈 줄 두개`로 구분한다.
- 클래스에서 메서드는 빈 줄 하나로 구분한다.
- 변수 할당 앞 뒤에 스페이스를 하나만 사용한다.
- 리스트 인덱스, 함수 홏ㄹ, 키워드 인수 할당에는 스페이스를 사용하지 않는다.



### naming

- 함수, 변수, 속성 : `lowercase_underscore`
- 보호(protected) 인스턴스 속성 : `_leading_underscore`
- 비공개(private) 인스턴스 속성 : `__double_leading_undersocre`
- 클래스와 예외 : `CapitalizeWord`
- 모듈 수준 상수 : ALL_CAPS
- 클래스의 인스턴스 메서드에서는 첫번째 파라미터 (해당 객체 참조)의 이름을 `self`로 지정
- 클래스 메서드에서는 첫번재 파라미터 (해당 클래스 참조)의 이름을 `cls`로 지정



### 표현식과 문장

- `if no a is b` 보다는 `if a is not b` 를 사용
- `if not somelist` 처럼 빈 값은 암시적으로 False가 된다고 가정
- `if somelist` 처럼 값이 있는 리스트는 암시적으로 True가 된다고 가정
- 한 줄로 된 if문, for, while loop, except 복합문을 쓰지 않는다.
- 항상 파일의 맨 위에 `import` 문을 놓는다.
- 모듈 임포트시에는 항상 모듈의 절대 이름을 사용 import foo 대신 from bar import foo
- 상대적인 임포트를 해야 한다면 명시적인 구문을 서서 from . import foo 라고 한다.
- 임포트 순서 : 표준 라이브러리 모듈 > 서드파티 모듈 > 자신이 만든 모듈 / 각각의 하위 섹션에서는 알파벳 순서